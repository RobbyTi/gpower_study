knitr::opts_chunk$set(include = FALSE) # this option stops the code chunks from being output from the knit
set.seed(1313)
library(tidyverse) # for cleaner code
library(knitr) # for kable function
library(kableExtra) # for kable table styling
library(irr) # for inter-rater agreement calculations
library(english) # to convert numbers to word equivalents via the function: words()
library(statpsych) # for the precision analysis
library(table1) # for making Table 1
# load the raw data
filepath <- paste0(getwd(), "/data/data_main_raw.csv" )
raw <- read.csv(filepath, header = TRUE)
df <- raw
df <- df %>%
# remove the columns for the initials of coders other than RTT, EZ, and HP (in the end, we only had these 3 coders)
select(-coder_text) %>%
# filter out the rows labeled "resolveNotes", in which we took some notes when resolving differences in coding in Google sheets.
filter(coder != "resolveNotes") %>%
filter(id != "") %>%   # remove two irrelevant rows that Qualtrics exports
filter(id != "156") %>%  # remove extra paper RTT coded after we had reached our sample size, but that no one else coded.
############# TEMPORARILY REMOVE THESE TWO, UNTIL HUGO CODES THEM
filter(id != "143") %>%
filter(id != "146") %>%
################
# recode the $power_text column to 0.80, where relevant. This is necessary as we updated the Qualtrics extraction form to add a button for "Yes (0.80)" to speed up coding
mutate(
power_text = if_else(power == "Yes (0.80)", "0.80", power_text),
power = if_else(power == "Yes (0.80)", "Yes", power),
# repeat for $alpha column
alpha_text = if_else(alpha == "Yes (0.05)", "0.05", alpha_text),
alpha = if_else(alpha == "Yes (0.05)", "Yes", alpha)
)
# recode Yes/No columns to 1 (yes), 0 (no), and NA
df <-
df %>%
mutate_at(c("version", "power", "alpha", "sample_size", "effect_size_value"),
~ case_when(
. == "Yes" ~ 1L,
. == "No" ~ 0L,
is.na(.) ~ NA_integer_)
) %>%
mutate(effect_size_type_binary =
case_when(
effect_size_type == "No" ~ 0L,
effect_size_type == "" ~ NA_integer_,
TRUE ~ 1L
),
stat_test_binary =
case_when(
stat_test == "the statistical test is NOT reported" ~ 0L,
stat_test == "" ~ NA_integer_,
TRUE ~ 1L
),
# make new column that checks how many sample size calculationss include all 6 elements
all6 = (
power + alpha + sample_size + effect_size_type_binary + effect_size_value + stat_test_binary
),
# recode some columns to binary that weren't previously only "Yes" and "No"
all6_binary =
case_when(
all6 == 6 ~ 1L,
all6 < 6 ~ 0L,
is.na(all6) ~ NA_integer_
),
reproducibile_binary =
case_when(
grepl("Yes", reproducible) ~ 1L,
reproducible == "No" ~ 0L,
is.na(reproducible) ~ NA_integer_
),
justification_binary =
case_when(
grepl("No justification", justification) ~ 0L,
is.na(justification) ~ NA_integer_,
TRUE ~ 1L,
)
)
# recode a few variables we changed during coding
df <- df %>%
mutate(anova_within_between =
case_when(
grepl("the default option without accounting", anova_within_between) ~ "Yes, but the researchers use the default option.",
grepl("Yes, and", anova_within_between) ~ "Yes, and the researchers selected a non-default option.",
TRUE ~ as.character(anova_within_between)  # Keep all other values as they are
)
) %>%
mutate(error =
case_when(
grepl("Likely", error) ~ "Unsure (there's not enough information to reasonably code yes or no).",
TRUE ~ as.character(error)  # Keep all other values as they are
)
) %>%
mutate(participants =
case_when(
grepl("Humans", participants) ~ "Human",
TRUE ~ "Non-human animal"
)
)
# recode a few columns to numerics
df$power_text <- as.numeric(df$power_text)
df$alpha_text <- as.numeric(df$alpha_text)
df$sample_size_text <- as.numeric(df$sample_size_text)
df$effect_size_value_text <- as.numeric(df$effect_size_value_text)
df$impact_factor <- as.numeric(df$impact_factor)
# decompose the justifications variable
df$just_previous <- ifelse(grepl("Previous", df$justification), 1, 0)
df$just_pilot <- ifelse(grepl("pilot data", df$justification), 1, 0)
df$just_convention <- ifelse(grepl("Convention", df$justification), 1, 0)
df$just_mcid <- ifelse(grepl("MCID", df$justification), 1, 0)
df$just_none <- ifelse(grepl("No justification", df$justification), 1, 0)
df$just_ref <- ifelse(grepl("Reference to other study", df$justification), 1, 0)
df$just_other <- ifelse(grepl("Other", df$justification), 1, 0)
# make a new dataframe that only includes the resolved coding
df1_all <- df %>% filter(grepl("/", coder))
# filter for articles that use GPower to solve for sample size
df1 <- df1_all %>% filter(grepl("Solves for sample size", power_calc_type))
# remove blank rows
df1 <- df1 %>%
select(-c(coder_number, participants_text, power_calc_type_text))
View(df_kappa)
proportion <- pmc_hits/pmc_total
pubmed_total/pmc_total
df1$sample_size
View(df1)
df1$sample_size_text
df1$sample_size_text %>% plot
df1$sample_size_text %>% plot()
library(tidyverse) # for cleaner code
df1$sample_size_text %>% plot()
df1$sample_size_text %>% hist()
df1$sample_size_text %>% summary()
df1$sample_size_text
df1$sample_size_text %>% quartile()
df1$sample_size_text %>% quintile(0.75)
df1$sample_size_text %>% quantile(0.75)
df1$sample_size_text %>% quantile(probs = 0.75)
quantile(df1$sample_size_text, probs = 0.75, na.rm = T)
quantile(df1$sample_size_text, probs = 0.25, na.rm = T)
calc_type
