# filter out the rows labeled "resolveNotes", in which we took some notes when resolving differences in coding.
filter(coder != "resolveNotes") %>%
filter(id != "") %>%   # remove two irrelevant rows that Qualtrics exports
filter(id != "156") %>%  # remove extra paper RTT coded after we had reached our sample size, but that no one else coded.
############# TEMPORARILY REMOVE THESE TWO, UNTIL HUGO CODES THEM
filter(id != "143") %>%
filter(id != "146") %>%
################
# recode the $power_text column to 0.80, where relevant. This is necessary as we updated the Qualtrics extraction form to add a button for "Yes (0.80)" to speed up coding
mutate(
power_text = if_else(power == "Yes (0.80)", "0.80", power_text),
power = if_else(power == "Yes (0.80)", "Yes", power),
# repeat for $alpha column
alpha_text = if_else(alpha == "Yes (0.05)", "0.05", alpha_text),
alpha = if_else(alpha == "Yes (0.05)", "Yes", alpha)
)
# recode Yes/No columns to 1 (yes), 0 (no), and NA
df <-
df %>%
mutate_at(c("version", "power", "alpha", "sample_size", "effect_size_value"),
~ case_when(
. == "Yes" ~ 1L,
. == "No" ~ 0L,
is.na(.) ~ NA_integer_)
) %>%
mutate(effect_size_type_binary =
case_when(
effect_size_type == "No" ~ 0L,
effect_size_type == "" ~ NA_integer_,
TRUE ~ 1L
),
stat_test_binary =
case_when(
stat_test == "the statistical test is NOT reported" ~ 0L,
stat_test == "" ~ NA_integer_,
TRUE ~ 1L
),
# make new column that checks how many power calcs include all 6 elements
all6 = (
power + alpha + sample_size + effect_size_type_binary + effect_size_value + stat_test_binary
),
# recode some columns to binary that weren't previously only "Yes" and "No"
all6_binary =
case_when(
all6 == 6 ~ 1L,
all6 < 6 ~ 0L,
is.na(all6) ~ NA_integer_
),
reproducibileBinary =
case_when(
grepl("Yes", reproducible) ~ 1L,
reproducible == "No" ~ 0L,
is.na(reproducible) ~ NA_integer_
),
JustificationBinary =
case_when(
grepl("No justification", justification) ~ 0L,
is.na(justification) ~ NA_integer_,
TRUE ~ 0L,
)
)
df$power
# recode Yes/No columns to 1 (yes), 0 (no), and NA
df <-
df %>%
mutate_at(c("version", "power", "alpha", "sample_size", "effect_size_value"),
~ case_when(
. == "Yes" ~ 1L,
. == "No" ~ 0L,
is.na(.) ~ NA_integer_)
) %>%
mutate(effect_size_type_binary =
case_when(
effect_size_type == "No" ~ 0L,
effect_size_type == "" ~ NA_integer_,
TRUE ~ 1L
),
stat_test_binary =
case_when(
stat_test == "the statistical test is NOT reported" ~ 0L,
stat_test == "" ~ NA_integer_,
TRUE ~ 1L
),
# make new column that checks how many power calcs include all 6 elements
all6 = (
power + alpha + sample_size + effect_size_type_binary + effect_size_value + stat_test_binary
),
# recode some columns to binary that weren't previously only "Yes" and "No"
all6_binary =
case_when(
all6 == 6 ~ 1L,
all6 < 6 ~ 0L,
is.na(all6) ~ NA_integer_
),
reproducibile_binary =
case_when(
grepl("Yes", reproducible) ~ 1L,
reproducible == "No" ~ 0L,
is.na(reproducible) ~ NA_integer_
),
justification_binary =
case_when(
grepl("No justification", justification) ~ 0L,
is.na(justification) ~ NA_integer_,
TRUE ~ 0L,
)
)
# recode a few columns to numerics
df$power_text <- as.numeric(df$power_text)
df$alpha_text <- as.numeric(df$alpha_text)
df$sample_size_text <- as.numeric(df$sample_size_text)
df$effect_size_value_text <- as.numeric(df$effect_size_value_text)
df$impact_factor <- as.numeric(df$impact_factor)
# make a new dataframe that only includes the resolved coding
df1_all <- df %>% filter(grepl("/", coder))
# filter for articles that use GPower to solve for sample size
df1 <- df1_all %>% filter(grepl("Solves for sample size", power_calc_type))
df1$anova_within_between
df1$anova_within_between %>% table()
df <- df %>%
mutate(anova_within_between =
case_when(
grepl("default option", anova_within_between) ~ "Yes, but the researchers use the default option."
)
)
df$anova_within_between
df$anova_within_between %>% table()
df1$anova_within_between %>% table()
# load the raw data
filepath <- paste0(getwd(), "/gpower_dataset_230915.csv" )
raw <- read.csv(filepath, header = TRUE)
df <- raw
df <-
df %>%
# remove the columns for the initials of coders other than RTT, EZ, and HP (in the end, we only had these 3 coders)
select(-coder_text) %>%
# filter out the rows labeled "resolveNotes", in which we took some notes when resolving differences in coding.
filter(coder != "resolveNotes") %>%
filter(id != "") %>%   # remove two irrelevant rows that Qualtrics exports
filter(id != "156") %>%  # remove extra paper RTT coded after we had reached our sample size, but that no one else coded.
############# TEMPORARILY REMOVE THESE TWO, UNTIL HUGO CODES THEM
filter(id != "143") %>%
filter(id != "146") %>%
################
# recode the $power_text column to 0.80, where relevant. This is necessary as we updated the Qualtrics extraction form to add a button for "Yes (0.80)" to speed up coding
mutate(
power_text = if_else(power == "Yes (0.80)", "0.80", power_text),
power = if_else(power == "Yes (0.80)", "Yes", power),
# repeat for $alpha column
alpha_text = if_else(alpha == "Yes (0.05)", "0.05", alpha_text),
alpha = if_else(alpha == "Yes (0.05)", "Yes", alpha)
)
df <- df %>%
mutate(anova_within_between =
case_when(
grepl("the default option", anova_within_between) ~ "Yes, but the researchers use the default option.",
grepl("non-default option", anova_within_between) ~ "Yes, and the researchers selected a non-default option.",
TRUE ~ as.character(anova_within_between)  # Keep all other values as they are
)
)
df$anova_within_between %>% table()
df1$error %>%  table()
df1$error_text
df1$error %>% table()
# recode a few variables we changed during coding
df <- df %>%
mutate(anova_within_between =
case_when(
grepl("the default option", anova_within_between) ~ "Yes, but the researchers use the default option.",
grepl("non-default option", anova_within_between) ~ "Yes, and the researchers selected a non-default option.",
TRUE ~ as.character(anova_within_between)  # Keep all other values as they are
)
) %>%
mutate(error =
case_when(
grepl("Likely", anova_within_between) ~ "Unsure (there's not enough information to reasonably code yes or no).",
TRUE ~ as.character(anova_within_between)  # Keep all other values as they are
)
)
df$error %>%  table()
# recode a few variables we changed during coding
df <- df %>%
mutate(anova_within_between =
case_when(
grepl("the default option", anova_within_between) ~ "Yes, but the researchers use the default option.",
grepl("non-default option", anova_within_between) ~ "Yes, and the researchers selected a non-default option.",
TRUE ~ as.character(anova_within_between)  # Keep all other values as they are
)
) %>%
mutate(error =
case_when(
grepl("Likely", anova_within_between) ~ "Unsure (there's not enough information to reasonably code yes or no).",
TRUE ~ as.character(error)  # Keep all other values as they are
)
)
df$error %>% table()
# recode a few columns to numerics
df$power_text <- as.numeric(df$power_text)
df$alpha_text <- as.numeric(df$alpha_text)
df$sample_size_text <- as.numeric(df$sample_size_text)
df$effect_size_value_text <- as.numeric(df$effect_size_value_text)
df$impact_factor <- as.numeric(df$impact_factor)
# make a new dataframe that only includes the resolved coding
df1_all <- df %>% filter(grepl("/", coder))
# filter for articles that use GPower to solve for sample size
df1 <- df1_all %>% filter(grepl("Solves for sample size", power_calc_type))
df1$error %>% table()
# load the raw data
filepath <- paste0(getwd(), "/gpower_dataset_230915.csv" )
raw <- read.csv(filepath, header = TRUE)
df <- raw
df <-
df %>%
# remove the columns for the initials of coders other than RTT, EZ, and HP (in the end, we only had these 3 coders)
select(-coder_text) %>%
# filter out the rows labeled "resolveNotes", in which we took some notes when resolving differences in coding.
filter(coder != "resolveNotes") %>%
filter(id != "") %>%   # remove two irrelevant rows that Qualtrics exports
filter(id != "156") %>%  # remove extra paper RTT coded after we had reached our sample size, but that no one else coded.
############# TEMPORARILY REMOVE THESE TWO, UNTIL HUGO CODES THEM
filter(id != "143") %>%
filter(id != "146") %>%
################
# recode the $power_text column to 0.80, where relevant. This is necessary as we updated the Qualtrics extraction form to add a button for "Yes (0.80)" to speed up coding
mutate(
power_text = if_else(power == "Yes (0.80)", "0.80", power_text),
power = if_else(power == "Yes (0.80)", "Yes", power),
# repeat for $alpha column
alpha_text = if_else(alpha == "Yes (0.05)", "0.05", alpha_text),
alpha = if_else(alpha == "Yes (0.05)", "Yes", alpha)
)
# recode Yes/No columns to 1 (yes), 0 (no), and NA
df <-
df %>%
mutate_at(c("version", "power", "alpha", "sample_size", "effect_size_value"),
~ case_when(
. == "Yes" ~ 1L,
. == "No" ~ 0L,
is.na(.) ~ NA_integer_)
) %>%
mutate(effect_size_type_binary =
case_when(
effect_size_type == "No" ~ 0L,
effect_size_type == "" ~ NA_integer_,
TRUE ~ 1L
),
stat_test_binary =
case_when(
stat_test == "the statistical test is NOT reported" ~ 0L,
stat_test == "" ~ NA_integer_,
TRUE ~ 1L
),
# make new column that checks how many power calcs include all 6 elements
all6 = (
power + alpha + sample_size + effect_size_type_binary + effect_size_value + stat_test_binary
),
# recode some columns to binary that weren't previously only "Yes" and "No"
all6_binary =
case_when(
all6 == 6 ~ 1L,
all6 < 6 ~ 0L,
is.na(all6) ~ NA_integer_
),
reproducibile_binary =
case_when(
grepl("Yes", reproducible) ~ 1L,
reproducible == "No" ~ 0L,
is.na(reproducible) ~ NA_integer_
),
justification_binary =
case_when(
grepl("No justification", justification) ~ 0L,
is.na(justification) ~ NA_integer_,
TRUE ~ 0L,
)
)
# recode a few variables we changed during coding
df <- df %>%
mutate(anova_within_between =
case_when(
grepl("the default option", anova_within_between) ~ "Yes, but the researchers use the default option.",
grepl("non-default option", anova_within_between) ~ "Yes, and the researchers selected a non-default option.",
TRUE ~ as.character(anova_within_between)  # Keep all other values as they are
)
) %>%
mutate(error =
case_when(
grepl("Likely", anova_within_between) ~ "Unsure (there's not enough information to reasonably code yes or no).",
TRUE ~ as.character(error)  # Keep all other values as they are
)
)
# recode a few columns to numerics
df$power_text <- as.numeric(df$power_text)
df$alpha_text <- as.numeric(df$alpha_text)
df$sample_size_text <- as.numeric(df$sample_size_text)
df$effect_size_value_text <- as.numeric(df$effect_size_value_text)
df$impact_factor <- as.numeric(df$impact_factor)
# make a new dataframe that only includes the resolved coding
df1_all <- df %>% filter(grepl("/", coder))
# filter for articles that use GPower to solve for sample size
df1 <- df1_all %>% filter(grepl("Solves for sample size", power_calc_type))
df1$error %>% table()
df1$anova_within_between %>% table()
# recode a few variables we changed during coding
df <- df %>%
mutate(anova_within_between =
case_when(
grepl("the default option", anova_within_between) ~ "Yes, but the researchers use the default option.",
grepl("non-default option", anova_within_between) ~ "Yes, and the researchers selected a non-default option.",
TRUE ~ as.character(anova_within_between)  # Keep all other values as they are
)
) %>%
mutate(error =
case_when(
grepl("Likely", error) ~ "Unsure (there's not enough information to reasonably code yes or no).",
TRUE ~ as.character(error)  # Keep all other values as they are
)
)
# recode a few columns to numerics
df$power_text <- as.numeric(df$power_text)
df$alpha_text <- as.numeric(df$alpha_text)
df$sample_size_text <- as.numeric(df$sample_size_text)
df$effect_size_value_text <- as.numeric(df$effect_size_value_text)
df$impact_factor <- as.numeric(df$impact_factor)
# make a new dataframe that only includes the resolved coding
df1_all <- df %>% filter(grepl("/", coder))
# filter for articles that use GPower to solve for sample size
df1 <- df1_all %>% filter(grepl("Solves for sample size", power_calc_type))
df1$error %>% table()
View(df1)
# remove blank rows
df1 <- df1 %>%
select(-c(coder_number, participants_text, power_calc_type_text, X))
# decompose the justifications variable
df$just_previous <- ifelse(grepl("Previous", df$justification), 1, 0)
df$just_previous
df$just_previous <- ifelse(grepl("Previous", df$justification), 1, 0)
df$just_pilot <- ifelse(grepl("pilot data", df$justification), 1, 0)
df$just_convention <- ifelse(grepl("Convention", df$justification), 1, 0)
df$just_mcid <- ifelse(grepl("MCID", df$justification), 1, 0)
df$just_none <- ifelse(grepl("No justification", df$justification), 1, 0)
df$just_ref <- ifelse(grepl("Reference to other study", df$justification), 1, 0)
df$just_other <- ifelse(grepl("Other", df$justification), 1, 0)
View(df)
# make a new dataframe that only includes the resolved coding
df1_all <- df %>% filter(grepl("/", coder))
# filter for articles that use GPower to solve for sample size
df1 <- df1_all %>% filter(grepl("Solves for sample size", power_calc_type))
# remove blank rows
df1 <- df1 %>%
select(-c(coder_number, participants_text, power_calc_type_text, X))
df1$justification
write_csv(df1, "dataClean.csv")
inter_rater <- function(df, variables, prescreen_questions){
# Initialize an empty list to store results
kappa_results <- data.frame(matrix(nrow = length(variables), ncol = 5))
colnames(kappa_results) <- c("k", "percent_agreed", "n_disagreed", "n_total", "n_categories")
rownames(kappa_results) <- variables
# Loop through each variable
for (var in variables) {
if(prescreen_questions == TRUE){
# Subset data for each coder and specific variable
data1 <- subset(df, coder == "RTT")[, var]
data2 <- subset(df, coder == "EZ")[, var]
} else {
data1 <- subset(df, coder_number == 1)[, var]
data2 <- subset(df, coder_number == 2)[, var]
}
# Combine into a matrix
combined_data <- matrix(c(data1, data2), ncol = 2)
# Calculate Cohen's Kappa
result <- kappa2(combined_data)
# Store the result in the list
kappa_results[[var, "k"]] <- result$value %>% round(2)
kappa_results[[var, "percent_agreed"]] <- (sum(data1 == data2, na.rm = TRUE) / result$subjects) %>% round(2)
kappa_results[[var, "n_disagreed"]] <- sum(data1 != data2, na.rm = TRUE)
kappa_results[[var, "n_total"]] <- result$subjects
kappa_results[[var, "n_categories"]] <- n_distinct(df[[var]])
}
return(kappa_results)
}
variables1 <- c(
"id",
#  "coder",
#  "coder_text",
#  "coder_numer",
"pmcid",
"protocol",
"include"
)
kappa_include <- inter_rater(df, variables1, TRUE)
# identify ids for included articles
id_include <- df %>% filter(grepl("/", coder)) %>%
filter(include == "Include") %>%
select(id)
# remove excluded articles based on their id. This is necessary to calculate inter-rater agreement for the other variables.
df_kappa <- df %>% filter(id %in% id_include$id)
# now that I've removed the excluded articles, I can calculate inter-rater agreement for the variables coded for all included article. All these questions were answered before the survey allowed the coder to select the option "I don't have the expertise for this article".
variables2 <- c(
"participants",
#  "participants_text",
"journal", # small difference in typing may result in different coding
#  "publisher", # recorded by one coder after all other coding was done (thus cannot calculate IRR)
"pub_year",
"impact_factor",
#  "verbatim",
"power_calc_type",
# "power_calc_type_text",
"multiple"
#  "stats_knowledge",
)
# Recode NAs to -100 in the "impact_factor" column
df_kappa$impact_factor <- ifelse(is.na(df_kappa$impact_factor), -100, df_kappa$impact_factor)
kappa_any_power_calc <- inter_rater(df_kappa, variables2, TRUE)
# return the impact factors to NA. I only needed them to be a number for the n_disagreement variable
# df$impact_factor <- ifelse(is.na(df$impact_factor), -100, df$impact_factor)
# identify ids for articles not solving for sample size
id_sample_size_calc <- df %>% filter(grepl("/", coder)) %>%
filter(power_calc_type == "Solves for sample size (often called a priori)") %>%
select(id)
# remove articles that don't solve for sample size based on their id. This is necessary to calculate inter-rater agreement for the other variables.
df_kappa <- df_kappa %>% filter(id %in% id_sample_size_calc$id)
# calculate inter-rater agreement for all relevant variables
# List of variables to check
variables3 <- c(
"version",
"version_text",
"power",
"power_text",
"alpha",
"alpha_text",
"sample_size",
"sample_size_text",
"effect_size_type",
#  "effect_size_type_other_standardized_text",
#  "effect_size_type_other_nonstandardized_text",
"effect_size_value",
"effect_size_value_text",
"stat_test",
#  "stat_test_other_regression_text",
#  "stat_test_other_nonregression_text",
#  "other_info_missing",
"reproducible",
#  "reproducible_text",
"justification",
"just_previous",
"just_pilot",
"just_convention",
"just_mcid",
"just_none",
"just_ref",
"just_other",
# "justification_text",
"mult_compare",
#  "mult_compare_text",
"anova_within_between",
"match",
#  "match_text",
"error"
#  "error_text",
#  "impact",
#  "comments_calc",
#  "comments_general",
#  "posthoc_resolving_notes"
)
kappa_sample_size_calc <- inter_rater(df_kappa, variables3, FALSE)
kappa_all <- rbind(kappa_include,
kappa_any_power_calc,
kappa_sample_size_calc
)
## print kappa_all as Table S1
View(kappa_all)
knitr::kable(kappa_all, caption = "Supplementary Table 1. Kappa", booktabs = T, linesep = "\\addlinespace") %>%
kable_styling(latex_options = "striped") %>%
add_footnote("footnote to add", notation = "none")
calc_type <- rbind(
sum(grepl("sample size", df1_all$power_calc_type)),
sum(grepl("power", df1_all$power_calc_type)),
sum(grepl("effect size", df1_all$power_calc_type)),
sum(grepl("Other", df1_all$power_calc_type)),
sum(grepl("Unsure", df1_all$power_calc_type))
) %>%
as.data.frame
rownames(calc_type) <- c("Sample  size",
"Power",
"Effect size",
"Sample size (after completing the study)",
"Unsure"
)
calc_type <- calc_type %>%
mutate(perc = V1 / sum(df1_all$include == "Include")) %>%
round(2)
# add row names
## print calc_type as Table S2. Include the numbers in the main manuscript.
calc_type
calc_type <- calc_type %>%
mutate(perc = V1 / sum(df1_all$include == "Include")) %>%
round(2)
included <- sum(df1_all$include == "Include")
included <- sum(df1_all$include == "Include")
calc_type <- calc_type %>%
mutate(perc = V1 / included) %>%
round(2)
colnames(calc_type) <- c("n",
"percentage"
)
calc_type
knitr::kable(calc_type, caption = "Table 2. Types of calculations...", booktabs = T, linesep = "\\addlinespace") %>%
kable_styling(latex_options = "striped") %>%
add_footnote("footnote to add", notation = "none")
cis_out
calc_type
